\documentclass{sumiilab-paper}

\usepackage[dvipdfmx]{graphicx} % 各種形式の画像を簡単にincludeできます
\usepackage{amsmath,amssymb} % 数式
\usepackage{bm}
\usepackage{mathtools} % 数学記号
\usepackage{cite} % 引用
\usepackage{enumitem} % リスト環境
\usepackage{bussproofs} % 証明器

\usepackage{listings, jvlisting} % ソースコード
\usepackage{listings-rust}
\usepackage{amsthm} % 定理環境

%% =========================================
%% 定理環境の設定
%% =========================================
\newtheoremstyle{mystyle}% name
{}% space above
{}% space below
{\normalfont}% body font
{}% indent amount
{\bfseries}% theorem head font
{ }% punctuation after theorem head
{4pt}% space after theorem head (default: 5pt)
{\thmname{#1}\thmnumber{#2}\thmnote{\hspace{2pt}(#3)}}% theorem head spec

\theoremstyle{mystyle}
\newtheorem{definition}{定義}
\newtheorem{theorem}[definition]{定理}
\newtheorem{corollary}[definition]{系}
\newtheorem{proposition}[definition]{命題}
\newtheorem{lemma}[definition]{補題}
\newtheorem{example}[definition]{例}
\newtheorem{assumption}[definition]{仮定}
\newtheorem{axiom}[definition]{公理}
\renewcommand{\proofname}{\bf{証明}}
\numberwithin{definition}{chapter} % 定義1.1のように表示

%% ソースコードのキャプション名
\renewcommand{\lstlistingname}{ソースコード}
%% ===============================================
%% 論文の表紙に表示される情報
%% ===============================================

% 論文の年度と種類
\paper{2023 年度 修士論文}

% 論文のタイトル
\title{RustへのFractional Ownershipの\\動的検査の導入}

% 学籍番号と著者のお名前
\author{C2IM1034 馬場 風汰}

% 著者の所属
\institute{東北大学 大学院情報科学研究科\\情報基礎科学専攻}% 修士

% 指導教員のお名前
\supervisor{住井 英二郎 教授}% 指導教員

% 論文発表日時
\date{2024年2月7日 10:50--11:50}
% \date{20XX 年1月1日 \quad 23:00--23:30}
% 発表場所
\venue{オンライン}

%% ===============================================
%% ソースコードの設定
%% ===============================================

% プログラミング言語と表示するフォント等の設定
\lstset{
  language={Rust},% プログラミング言語
  basicstyle={\ttfamily\small},% ソースコードのテキストのスタイル
  keywordstyle={\bfseries},% 予約語等のキーワードのスタイル
  commentstyle={},% コメントのスタイル
  stringstyle={},% 文字列のスタイル
  frame=trlb,% ソースコードの枠線の設定 (none だと非表示)
  numbers=left,% 行番号の表示 (none だと非表示)
  numberstyle={\footnotesize},% 行番号のスタイル
  xleftmargin=15pt,% 左余白
  xrightmargin=5pt,% 右余白
  keepspaces=true,% 空白を維持する
  mathescape,% $ で囲った部分を数式として表示する ($ がソースコード中で使えなくなるので注意)
  % 手動強調表示の設定
  moredelim=[is][\bfseries]{@*}{*@},
  moredelim=[is][\itshape]{@/}{/@}
}
\lstMakeShortInline[columns=fullflexible]|% 本文中にコードを|foo|の形式で書くことができます

%% ===============================================
%% 論文中で使う記号とかのマクロ定義
%% ===============================================

%% 論文中で繰り返し使う記号は次のように「マクロ」として実装しておくと良い。
%% TeX ソース中で \BOOL と書くと、\texttt{Bool} に置き換えてくれる。
%% フォントを変え忘れたりするリスクが減るし、あとから記号を変更するのも楽になる。

\newcommand{\bkeyword}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\BOOL}{\bkeyword{Bool}}
\newcommand{\TRUE}{\bkeyword{true}}
\newcommand{\FALSE}{\bkeyword{false}}
\newcommand{\IF}{\bkeyword{if}}
\newcommand{\THEN}{\bkeyword{then}}
\newcommand{\ELSE}{\bkeyword{else}}

\begin{document}
\frontmatter% ここから前文

\maketitle
% 予備審査の時の要旨
%   Rustはownershipという概念に基づいて安全な静的メモリ管理を行うプログラミング言語である。
% Rustでは、各オブジェクトに唯一のownerが静的に定められている。
% オブジェクトのメモリ領域は、ownerのスコープが終了すると開放される。
% ownershipは、変数への代入の際や関数に引数を渡す際に移動する。
% % *Borrowingの説明*また、オブジェクトが束縛されている変数の(Rustに特有の狭い意味での)参照を作成することで、ownerhsipを一時的に借りることができる。
% % *Lifetimeの説明*Rustでは、参照が有効であるプログラムの文面上の静的な範囲はライフタイムと呼ばれる。

% Rustの通常のスレッド生成では、共有オブジェクトのownershipはいずれか一つのスレッドのみに移動する。
% Rustには静的スコープつきスレッドも提供されているが、
% スレッドの合流が静的スコープに従う場合にしか用いることができない。
% また、RustのArcオブジェクトを用いることでオブジェクトの共有は可能であるが、
% メモリリークが起こる可能性がある。

% 以上のような問題に対処するため、本研究では
% fractional ownership [Boyland 2003]を導入する。
% Fractional ownershipとは、0以上かつ1以下の有理数であり、
% 1はオブジェクトが読み書き可能、0より大きく1未満の値は読み取りのみ可能であることを表す。
% オブジェクト生成時にはownershipとして1を与え、エイリアス生成時にはownershipを分割し、
% エイリアスが消滅する際にはownershipを集約する。
% 本研究ではRustの静的なownershipと、fractional ownershipの動的検査を組み合わせることにより、
% 静的スコープつきスレッドより柔軟に、競合状態を防止する手法を提案・実装する
% ここまで
\begin{abstract}

Rustはownership (所有権)の概念に基づいて安全な静的メモリ管理を行うプログラミング言語である。
Rustでは、各オブジェクトに唯一のownerが静的に定められている。
ownershipは、変数への代入や関数に引数を渡す際に移動する。
オブジェクトのメモリ領域は、ownerのスコープが終了すると解放される。
% *Borrowingの説明*また、オブジェクトが束縛されている変数の(Rustに特有の狭い意味での)参照を作成することで、ownerhsipを一時的に借りることができる。
% *Lifetimeの説明*Rustでは、参照が有効であるプログラムの文面上の静的な範囲はライフタイムと呼ばれる。

しかし、静的なownershipのみによるメモリ管理は柔軟性に欠ける場合がある。
そのためRustには
% 動的なメモリ管理が可能である
\texttt{Rc} (参照カウント) オブジェクトも存在する。
\texttt{Rc}オブジェクトはコンテナであり、中身のオブジェクトへの参照を持つ。
\texttt{Rc}オブジェクトはclone関数により複製でき、その際共通の参照カウントを1増やす。
複製が消滅する際には参照カウントを1減らし、
参照カウントが0になったら中身のオブジェクトを解放する。
そのため、
意図せず複製が残っていると
% 参照カウントが0にならないので
メモリリークのおそれがある。

そこで
本研究ではfractional ownership [Boyland 2003]の考え方を取り入れて、
Rustの静的なownershipによるメモリ管理と、動的な参照カウントの柔軟性を組み合わせる。
fractional ownershipとは0以上かつ1以下の有理数であり、
オブジェクト生成時にはownershipとして1を与え、参照複製時にはownershipを分割し、
複製された参照が消滅する際にはownershipを集約する。
また、オブジェクトの解放にはownership 1が必要であり、逆にownershipが0より大きいオブジェクトは
いずれ解放される必要がある。
本来fractional ownershipは静的に検査されるが、本研究では参照カウントを
動的なfractional ownershipとみなす方式を提案・実装する。
これにより、動的な参照カウントの柔軟性を活用した後、参照カウントが1になったオブジェクトはfractional ownership 1とみなし、
Rustの静的なownershipに戻すことができる。
逆に、静的なownershipに戻さないまま参照が消滅したら実行時エラーとすることにより、
オブジェクトの解放し忘れを検出することができる。
% 厳密な世界と動的な世界を行き来 dropの際は厳密な世界に戻らないといけない(新しい点ではない)


% この手法は、メモリ領域の解放が起きるタイミングがユーザの意図に反しないため
% RustのRcオブジェクトとは異なり、メモリリークを検出することができる。
% また、fractional ownershipの検査を、本来のように静的でなく
% 動的に行うことで、ベクターなどを用いた動的に検査ができない場合も
% 柔軟に検査を行うことができる。
% 具体的には、メモリ領域の解放のタイミングを指定し、解放が可能かを動的に検査するオブジェクトの実装を行った。
% TODO言い過ぎ（防ぐではなく検出してエラー）
% TODOメモリリークは検出できる（本来解放されているのに解放されていないと）
% TODOユーザの意図通りに解放できているかどうかを動的に検査
% 解放のタイミングを指定して、本当に解放できるかは動的に検査

\end{abstract}

\tableofcontents% 目次

\mainmatter% ここから本文

\chapter{序論}

\section{背景}
Rustは、実行時ガベージコレクタを基本的に使用せず、ownershipの概念に基づき静的なメモリ管理を行うプログラミング言語であり、システムプログラミング等に用いられる。
しかし、静的なownershipのみによるメモリ管理は柔軟性に欠ける場合があるため、
Rustには\texttt{Rc}(参照カウント)オブジェクトが存在する。
しかし、\texttt{Rc}オブジェクトを利用した際、
意図せず複製が残っている場合があり、
メモリリークのおそれがある。
\section{目的}
本研究では、fractional ownership [Boyland 2003]の考え方を取り入れて、
Rustの静的なownershipによるメモリ管理と、動的な参照カウントの柔軟性を組み合わせ、
ユーザの意図していないメモリリークを防ぐ方式を提案・実装することを目的とする。

\section{本論文の構成}
本論文では、まず第2章でRustのownership、\texttt{Rc}オブジェクト、並列処理について述べた後、第3章で本研究で提案する新たな参照オブジェクトについて述べる。その後第4章で新たな参照オブジェクトについての考察を述べ、第5章で関連研究、第6章で結論と今後の課題を述べる。

% %% 参考文献は \cite{ID} とします（ID は refs.bib 内で文献につけた識別子）
% %% BibTeX の使い方などは各自調べて下さい。
% %% 序論とか結論とか \cite{Pierce:TypeSystems}

\chapter{背景}

\section{Rustのownership}

\subsection{ownership}
Rustはownershipという概念に基づいて安全な静的メモリ管理を行っている。
Rustでは、各オブジェクトに唯一のownerが静的に定められており、
オブジェクトのメモリ領域は、ownerのスコープが終了すると開放される。
実際の例を以下のソースコード\ref{ownership_example}に示す。
3行目で、変数\texttt{s}は\texttt{String}オブジェクトのownerとなり、
4行目で、ownerである\texttt{s}のスコープが終了するため\texttt{String}オブジェクトのメモリ領域が解放される。

\begin{lstlisting}[language=Rust,caption=ownershipによるメモリ管理,label=ownership_example, captionpos=b]
fn main() {
  {
    let s = String::from("Hello");
  }
}
\end{lstlisting}
\subsection{move}
Rustでは、変数への代入や関数に引数を渡す際にownershipが移動する。これをmoveと呼ぶ。
変数への代入の際には以下のソースコード\ref{move_assign_example}のようにmoveが起きる。
2行目で、変数\texttt{s}が\texttt{String}オブジェクトのownerとなり、
3行目でsから\texttt{new\_s}にownershipがmoveしている。
ownershipがmoveしたことで\texttt{s}はownerでなくなるため、
4行目で\texttt{s}を利用しようとするとコンパイルエラーが発生する。
\begin{lstlisting}[language=Rust, caption=変数への代入でmoveが起こる例, label=move_assign_example, captionpos=b]
fn main() {
  let s = String::from("Hello");
  let new_s = s;
  s.push_str("World"); // Compile error!
}    
\end{lstlisting}
また、関数に引数を渡す際には以下のソースコード\ref{move_function_example}のようにmoveが起きる。
6行目で、変数\texttt{s}が\texttt{String}オブジェクトのownerとなり、
7行目で\texttt{s}から関数\texttt{f}の引数xにownershipがmoveしている。
ownershipがmoveしているため、\texttt{x}は\texttt{String}オブジェクトのownerとなり、
2行目の処理を行うことができる。
関数\texttt{f}の処理が終了した後、3行目で引数\texttt{x}の指す\texttt{String}オブジェクトが解放される。
そのため、8行目の時点で\texttt{s}はownerでないためコンパイルエラーが発生する。
さらに、8行目ですでに解放されている\texttt{String}オブジェクトに対して処理を行おうとしているため、実際に危険な処理となっている。
\begin{lstlisting}[language=Rust, caption=関数に引数を渡す際にmoveが起こる例, label=move_function_example, captionpos=b]
fn f(mut x: String) {
  x.push_str("World");
}

fn main() {
  let mut s = String::from("Hello");
  f(s);
  s.push_str("Oops!"); // Danger!
}
\end{lstlisting}

\subsection{borrowing}
実際のプログラムでは、ownershipを必ずmoveするのではなく、
一時的に借りたい場合がある。
Rustでは、特有の「参照」を作成することで
ownershipを一時的に借りることができる。これをborrowingと呼ぶ。
borrowingは、読み書き可能であるmutableなborrowingと読み取りのみ可能であるimmutableなborrowingに区別されており、変数名の前に\texttt{\&mut}とつけることでmutableなborroiwngが、\texttt{\&}とつけることでimmutableなborrowingができる。
ownershipをborrowingしている例を以下のソースコード\ref{borrowing_example}に示す。
6行目で、変数\texttt{s}が\texttt{String}オブジェクトのownerとなり、
7行目で\texttt{s}のownershipが一時的に関数\texttt{f}の引数\texttt{x}に貸しだされる。
ownershipが貸しだされているため、\texttt{x}は\texttt{String}オブジェクトのownerとなり、
2行目の処理を行うことができる。
関数\texttt{f}の処理が終了した後、\texttt{x}に貸しだされていたownershipは変数\texttt{s}に返却される。
そのため、8行目で\texttt{s}はownerであり、\texttt{s}に対して処理が可能である。

\begin{lstlisting}[language=Rust, caption=borrowingの例, label=borrowing_example, captionpos=b]
fn f(x: &String) {
  println!("{}", &x);
}

fn main() {
  let mut s = String::from("Hello");
  f(&s);
  s.push_str("World");
}
\end{lstlisting}

\subsection{lifetime}
borrowingによって貸し出されたownershipは、lifetimeという仕組みを利用して返却される。
lifetimeとは、参照を用いることができる範囲のことであり、以下のソースコード\ref{lifetime_example}のように
明示的に注釈をつけることもできる。
1行目のように書くことで、引数xのlifetimeが関数fの本体と一致していると注釈でき、
関数fの処理が終了したとき、xのlifetimeも終了するため、その時点でownershipが返却される。
\begin{lstlisting}[language=Rust, caption=lifetime注釈, label=lifetime_example, captionpos=b]
fn f<'a>(x: &'a String) {
  println!("{}", &x);
}

fn main() {
  let mut s = String::from("Hello");
  f(&s);
  s.push_str("World");
}
\end{lstlisting}

\section{Rc}
Rustの静的なownershipのみによるメモリ管理は柔軟性に欠ける場合があるため、Rustには\texttt{Rc} (参照カウント) オブジェクトも存在する。
\texttt{Rc}オブジェクトはコンテナであり、中身のオブジェクトへの参照と、共通の参照カウントを持つ。
また、\texttt{clone}関数により複製でき、その際共通の参照カウントを1増やす。
複製が消滅する際には参照カウントを1減らし、
参照カウントが0になったら中身のオブジェクトを解放する。

実際には、以下のソースコード\ref{rc_example}のように用いられる。
このプログラムは、中身に\texttt{Hello}という\texttt{String}オブジェクトを持つ\texttt{Rc}オブジェクト\texttt{h}と、中身に\texttt{World}という\texttt{String}オブジェクトを持つ\texttt{Rc}オブジェクト\texttt{w}の複製をランダムに10回配列に入れ、その配列から\texttt{Hello}という\texttt{String}オブジェクトを持つ\texttt{Rc}オブジェクトを削除するプログラムである。配列の要素は実行する度に変化するため、静的なownershipのみではメモリ管理が難しい例である。
12行目と16行目では\texttt{clone}関数により、\texttt{Rc}オブジェクトの複製を生成し、参照カウントが1増えている。
20行目で\texttt{h}の複製は1つを残してすべて消滅し、\texttt{h}の参照カウントは1まで減少する。
最後に21行目で\texttt{h}、\texttt{w}の参照カウントは0となり、中身のオブジェクトが解放される。
\begin{lstlisting}[language=Rust, caption=Rcオブジェクトの利用例, label=rc_example, captionpos=b]
fn remove_string(vec: &mut Vec<Rc<String>>, s: String) {
    vec.retain(|x| **x != s);
}

fn main() {
    let mut vec: Vec<Rc<String>> = Vec::new();
    let h = Rc::new(String::from("Hello"));
    let w = Rc::new(String::from("World"));
    let mut rng = rand::thread_rng();
    for _ in 0..10 {
        if rng.gen() {
            let h_clone = h.clone();
            vec.push(h_clone);
        }
        else {
            let w_clone = w.clone();
            vec.push(w_clone);
        }
    }
    remove_string(&mut vec, String::from("Hello"));
}
\end{lstlisting}

\section{Rcの問題点}
仮に上のソースコード\ref{rc_example}において、20行目の直後に\texttt{Rc}オブジェクト\texttt{h}と\texttt{Rc}オブジェクト\texttt{w}を用いない処理が行われているとする。このとき、2つの\texttt{Rc}オブジェクトの中身が解放されるのは21行目で\texttt{main}関数のスコープが終了したときであり、追加した新たな処理で\texttt{h}も\texttt{w}もどちらも利用していないにもかかわらずメモリ領域が確保されたままとなってしまう。このように、\texttt{Rc}オブジェクトを用いた場合、意図せずメモリリークが発生するおそれがある。

\section{Rustの並列処理}
静的なownershipで柔軟性に欠ける例として、並列処理の例もある。

\subsection{通常のスレッド}
Rustの通常のスレッド生成では、ownerは高々一つのスレッドにmoveし、複数のスレッドにmoveすることはできない。以下のソースコード\ref{thread_example}は、Rustで通常のスレッドを生成する例であり、3行目にある\texttt{move}キーワードによりmoveが起きる。
\begin{lstlisting}[language=Rust, caption=Rustでの通常のスレッド生成の例, label=thread_example, captionpos=b]
fn main() {
    let s = String::from("Hello");
    thread::spawn(move || {
        println!("{}", s);
    });
}
\end{lstlisting}

Rustでは、スレッドのライフタイムは無限とみなされており、スレッドが合流した際にownershipが返却されないため、共有オブジェクトに対するborrowingは不可能である。

\subsection{scoped thread}
共有オブジェクトに対するborrowingができないことは不便であるため、Rustにはスレッドをまたいだborrowingを可能にするscoped threadが存在する。
これは、スレッドに静的スコープを付与したものであり、静的スコープに従ってスレッドの合流が起きるため、共有オブジェクトに対するborrowingが可能となる。
以下のソースコード\ref{scoped_thread_example}は、scoped threadを利用した例である。スレッドに付与されたスコープは、10行目で終了しスレッドの合流が起こる。
\begin{lstlisting}[language=Rust, caption=scoped threadの例, label=scoped_thread_example, captionpos=b]
fn main () {
    let mut s = String::from("Hello");
    thread::scope(|sc| {
        sc.spawn(|| {
            println!("{}", &s);
        });
        sc.spawn(|| {
            println!("{}", &s);
        });
    });
    s.push_str("World");
}
\end{lstlisting}

\section{並列処理の際の問題点}
以下ソースコード\ref{scoped_thread_problem}はscoped threadで表すことができない。
関数\texttt{my\_spawn}は、引数として\texttt{String}オブジェクトを受け取り、スレッドを生成し、スレッドのハンドラを返す関数である。
このプログラムは、関数\texttt{my\_spawn}により\texttt{main}関数外で生成したスレッドが\texttt{main}関数内で合流するというプログラムである。
このプログラムは、スレッドの合流が静的スコープに従っていないため、scoped threadで表すことができない例である。
\begin{lstlisting}[language=Rust, caption=scoped threadで表せない例, label=scoped_thread_problem, captionpos=b]
fn my_spawn (a: &String) -> JoinHandle<()>{
    let t = thread::spawn(|| {
        println!("{}", &a);
    });
    return t
}
fn main() {
    let mut a = String::from("Hello");
    let t1 = my_spawn(&a);
    let t2 = my_spawn(&a);
    t1.join();
    t2.join();
    a.push_str(“World”);
}
\end{lstlisting}

\chapter{分数権限を動的に検査する参照オブジェクトの提案}
本研究では、Rustの静的なownershipによるメモリ管理と、
動的な参照カウントの柔軟性を組み合わせた新たな参照オブジェクトを提案する。
この参照オブジェクトは、fractional ownership [Boyland 2003]の考え方を取り入れている。

\section{fractional ownership}
fractional ownershipとは0以上かつ1以下の有理数であり、オブジェクト生成時にはownershipとして1を与え、参照複製時にはownershipを分割し、複製された参照が消滅する際にはownershipを集約する。また、オブジェクトの解放にはownership 1が必要であり、逆にownershipが0より大きいオブジェクトはいずれ解放される必要がある。本来 fractional ownership は静的に検査されるが、本研究では参照カウントを動的な fractional ownership とみなす方式を提案・実装する。

\section{インターフェース}
本研究で提案する新たな参照オブジェクトは、読み書き可能であるmutableな参照オブジェクトと
読み取りのみ可能であるimmutableな参照オブジェクトの2つがあり、静的に区別されている。
mutableな参照はRustの通常のownershipに従い、同時に一つしか存在しない。
\texttt{to\_immut}関数を用いると、mutableな参照をimmutableな参照に変換でき、
その際Rustの静的なownershipのmoveによりmutableな参照は消滅する。
immutableな参照は、Rustの通常のownershipに違反して\texttt{clone\_immut}関数により複製が可能であり、複製の数を動的にカウントする。
参照カウントが1つであるときのみ、\texttt{back\_to\_immut}関数を用いてimmutableな参照からmutableな参照へ変換でき、その際moveによりimmutableな参照は消滅する。

実際のプログラムでは以下のソースコード\ref{interface}のように利用する。
2行目で、\texttt{new}関数を用いて\texttt{String}オブジェクトを保持するmutableな参照オブジェクトを生成し、3行目で\texttt{to\_immut}関数によりimmutableな参照オブジェクトへと変換している。その後、4行目で\texttt{clone\_immut}関数によりimmutableな参照オブジェクトを複製している。その際参照カウントは増加し、2となる。5行目でimmutableな参照を利用した後、6行目で明示的に複製を消滅させている。消滅したことで参照カウントは減少し、1となる。
参照カウントが1であるため、7行目で\texttt{back\_to\_mut}関数によりmutableな参照に変換でき、その後8行目で書き換えを行うことができる。
\begin{lstlisting}[language=Rust, caption=新たな参照オブジェクトの利用例, label=interface, captionpos=b]
fn main() {
    let mut h = RefMut::new(String::from("Hello"));
    let h_immut1 = h.to_immut();
    let h_immut2 = h_immut1.clone_immut();
    println!("{},{}", h_immut1, h_immut2);
    drop(h_immut2);
    let mut h_mut = h_immut1.back_to_mut();
    h_mut.push_str("World");
    println!("{}", h_mut);
}
\end{lstlisting}

\section{実装}
mutableな参照オブジェクト、immutableな参照オブジェクトは以下のソースコード\ref{struct_implementation}のように実装した。
mutableな参照オブジェクトは、オブジェクトを保持するコンテナとして実装した。
immutableな参照オブジェクトは、Rustのownershipを無視する特別なポインタであるNonNullオブジェクトを保持するオブジェクトとして実装した。NonNullオブジェクトにより、参照の複製が可能になる。immutableな参照内のポインタはNewRefInnerオブジェクトへのポインタであり、このオブジェクトは参照カウントと中身のオブジェクトを保持する。
\begin{lstlisting}[language=Rust, caption=新たな参照オブジェクトの実装, label=struct_implementation, captionpos=b]
pub struct RefMut<T: ?Sized> {
    data: T,
}
pub struct RefImmut<T: ?Sized> {
    ptr: NonNull<NewRefInner<T>>
}
struct NewRefInner<T: ?Sized> {
    ref_count: atomic::AtomicUsize,
    data: T
}
\end{lstlisting}

mutableな参照オブジェクトを生成する\texttt{new}関数とmutableな参照オブジェクトを引数として受け取り、immutableな参照オブジェクトに変換して返す\texttt{to\_immut}関数は以下のソースコード\ref{new_to_implementation}ように実装した。
4行目で\texttt{to\_immut}関数の引数は、borrowingでなくmoveが起きるようにすることで、
変換した後引数のmutableな参照が消滅するように実装した。
\begin{lstlisting}[language=Rust, caption=関数newと関数to\_immutの実装, label=new_to_implementation, captionpos=b]
pub fn new(data: T) -> RefMut<T> {
    Self { data: data }
}
pub fn to_immut(self: RefMut<T>) -> RefImmut<T> {
    let mut this = ManuallyDrop::new(self);
    let inner =
        unsafe{ptr::read(Self::get_mut_unchecked(&mut this))};
    let x: Box<_> = Box::new(NewRefInner {
        ref_count: AtomicUsize::new(1),
        data: inner,
    });
    RefImmut {ptr: Box::leak(x).into()}
}
\end{lstlisting}

immutableな参照オブジェクトを引数として受け取り、複製した参照を返す\texttt{clone\_immut}関数は次のソースコード\ref{clone_implementation}ように実装した。\texttt{clone\_immut}関数の引数をborrowingにすることで、複製元の参照が消滅せずに利用できるように実装した。また、2行目の\texttt{fetch\_add}関数によってimmutableな参照の内部の参照カウントが1増加するように実装した。
\begin{lstlisting}[language=Rust, caption=関数clone\_immutの実装, label=clone_implementation, captionpos=b]
pub fn clone_immut(&self: &RefImmut<T>) -> RefImmut<T> {
    let old_size = self.inner().ref_count.fetch_add(1, Release);
    if old_size > MAX_REFCOUNT {
        abort();
    }
    RefImmut { ptr: self.ptr }
}
\end{lstlisting}

immutableな参照オブジェクトを引数として受け取り、mutableな参照オブジェクトに変換し返す\texttt{back\_to\_mut}関数は次のソースコード\ref{back_implementation}のように実装した。\texttt{back\_to\_mut}関数の引数をborowwingでなくmoveするようにし、変換した後引数のimmutableな参照が消滅するように実装した。また、2行目でimmutableな参照の参照カウントが1でなければ実行時エラーが起きるようにし、immutableな参照のままでは消滅できないように実装した。
\begin{lstlisting}[language=Rust, caption=関数back\_to\_mutの実装, label=back_implementation, captionpos=b]
pub fn back_to_mut(self: RefImmut<T>) -> RefMut<T> {
    if self.inner().ref_count.load(Acquire) != 1{
        panic!("cannot back to mut");
    }
    let mut this = ManuallyDrop::new(self);
    let inner =
        unsafe { ptr::read(Self::get_mut_unchecked(&mut this))};
    unsafe {
        dealloc(this.ptr.cast().as_mut(), 
        Layout::for_value_raw(this.ptr.as_ptr()))
    }
    RefMut { data: inner }
}
\end{lstlisting}

immutableな参照を引数として受け取り、その参照を消滅させる\texttt{drop}関数は以下のソースコード\ref{drop_implementation}のように実装した。参照カウントが2以上である場合は、参照カウントを1減少させ、参照カウントが1である場合は実行時エラーが起きるようにすることで、immutableな参照をmutableな参照に戻さずに消滅できなように実装した。これにより、オブジェクトの解放し忘れを検出することが可能である。
\begin{lstlisting}[language=Rust, caption=関数back\_to\_mutの実装, label=drop_implementation, captionpos=b]
fn drop(&mut self) {
    let count = self.inner().ref_count.fetch_sub(1, Relaxed);
    if count > 1{
        return
    }
    else if count == 1{
        if panicking() {
            return
        }
        unsafe {
            dealloc(self.ptr.cast().as_mut(), 
            Layout::for_value_raw(self.ptr.as_ptr()))
        }
        panic!("cannot drop");
    }
    else {
        abort();
    }
}
\end{lstlisting}

\section{例}
実際のプログラムで、本研究の参照オブジェクトを利用した例が以下のソースコード\ref{random_example}である。
このプログラムは、中身に\texttt{Hello}という\texttt{String}オブジェクトを持つmutableな参照オブジェクト\texttt{h}と、中身に\texttt{World}という\texttt{String}オブジェクトを持つmutableな参照オブジェクト\texttt{w}をどちらもimmutableな参照オブジェクトに変換した後、複製をランダムに10回配列に入れ、その配列から\texttt{Hello}という\texttt{String}オブジェクトを持つimmutableな参照オブジェクトを削除するプログラムである。
7、8行目で生成したmutableな参照を、10、11行目でimmutableな参照に変換し、14、19行目でimmutableな参照を複製している。\texttt{remove\_string}が終了した後、26行目、32行目でmutableな参照に戻している。
\begin{lstlisting}[language=Rust, caption=新たな参照オブジェクトを用いた柔軟なメモリ管理の例, label=random_example, captionpos=b]
fn remove_string(vec: &mut Vec<RefImmut<String>>, s: String) {
    vec.retain(|x| **x != s);
}

fn main() {
    let mut vec: Vec<RefImmut<String>> = Vec::new();
    let mut h = RefMut::new(String::from("Hello"));
    let mut w = RefMut::new(String::from("World"));
    let mut rng = rand::thread_rng();
    let h_immut = h.to_immut();
    let w_immut = w.to_immut();
    for _ in 0..10 {
        if rng.gen() {
            let h_immut1 = h_immut.clone_immut();
            println!("{}", h_immut1);
            vec.push(h_immut1);
        }
        else {
            let w_immut1 = w_immut.clone_immut();
            println!("{}", w_immut1);
            vec.push(w_immut1);
        }
    }

    remove_string(&mut vec, String::from("Hello"));
    let mut h_mut = h_immut.back_to_mut();
    h_mut.push_str("hoge");
    println!("{}", h_mut);
    drop(h_mut);

    drop(vec);
    let mut w_mut = w_immut.back_to_mut();
}
\end{lstlisting}

以下のソースコード\ref{error_example1}は、ソースコード\ref{random_example}とほぼ同じプログラムであるが、immutableな参照をmutableな参照に戻していないプログラムである。
この場合、mutableな参照に戻さないまま参照が消滅してしまっているため実行時エラーが発生し、オブジェクトの解放し忘れを検出することができる。
\begin{lstlisting}[language=Rust, caption=オブジェクトの解放し忘れを検出する例, label=error_example1, captionpos=b]
fn remove_string(vec: &mut Vec<RefImmut<String>>, s: String) {
    vec.retain(|x| **x != s);
}

fn main() {
    let mut vec: Vec<RefImmut<String>> = Vec::new();
    let mut h = RefMut::new(String::from("Hello"));
    let mut w = RefMut::new(String::from("World"));
    let mut rng = rand::thread_rng();
    let h_immut = h.to_immut();
    let w_immut = w.to_immut();
    for _ in 0..10 {
        if rng.gen() {
            let h_immut1 = h_immut.clone_immut();
            println!("{}", h_immut1);
            vec.push(h_immut1);
        }
        else {
            let w_immut1 = w_immut.clone_immut();
            println!("{}", w_immut1);
            vec.push(w_immut1);
        }
    }

    remove_string(&mut vec, String::from("Hello"));
}
\end{lstlisting}

以下のソースコード\ref{error_example2}は、ソースコード\ref{random_example}とほぼ同じプログラムであるが、参照カウントが1でないにも関わらずimmutableな参照をmutableな参照に戻そうとしているプログラムである。
この場合、mutableな参照に戻すことができずに実行時エラーが発生するため、mutableな参照でないと消滅させることはできないようユーザに強制することができている。
\begin{lstlisting}[language=Rust, caption=mutableな参照へ戻せないことを検出する例, label=error_example2, captionpos=b]
fn remove_string(vec: &mut Vec<RefImmut<String>>, s: String) {
    vec.retain(|x| **x != s);
}

fn main() {
    let mut vec: Vec<RefImmut<String>> = Vec::new();
    let mut h = RefMut::new(String::from("Hello"));
    let mut w = RefMut::new(String::from("World"));
    let mut rng = rand::thread_rng();
    let h_immut = h.to_immut();
    let w_immut = w.to_immut();
    for _ in 0..10 {
        if rng.gen() {
            let h_immut1 = h_immut.clone_immut();
            println!("{}", h_immut1);
            vec.push(h_immut1);
        }
        else {
            let w_immut1 = w_immut.clone_immut();
            println!("{}", w_immut1);
            vec.push(w_immut1);
        }
    }

    remove_string(&mut vec, String::from("Hello"));
    let mut w_mut = w_immut.back_to_mut();
    w_mut.push_str("hhhhh");
    println!("{}", w_mut);
}
\end{lstlisting}

また、スレッドの合流が静的スコープに従わない並列処理は、本研究の新たな参照オブジェクトにより以下のソースコード\ref{scoped_example}のように表すことができる。
関数\texttt{my\_spawn}は、引数として\texttt{String}オブジェクトへのimmutableな参照を受け取り、スレッドを生成し、スレッドのハンドラを返す関数である。
このプログラムは、関数\texttt{my\_spawn}により\texttt{main}関数外で生成したスレッドが\texttt{main}関数内で合流するというプログラムである。
8行目でmutableな参照を生成し、9、10行目でimmutableな参照に変換した後、複製している。その後、関数\texttt{my\_spawn}によりスレッドを生成し、13、14行目で\texttt{main}関数内でスレッドが合流している。その後関数\texttt{drop}によりownershipの集約が起き、関数\texttt{back\_to\_mut}によりmutableな参照に戻している。
\begin{lstlisting}[language=Rust, caption=新たな参照オブジェクトを用いた並列処理の例, label=scoped_example, captionpos=b]
fn my_spawn (a: &RefImmut<String>) -> JoinHandle<()>{
    let t = thread::spawn(||{
        println!("{}", a);
    });
    return t
}
fn main() {
    let mut s = RefMut::new(String::from("Hello"));
    let s1 = s.to_immut();
    let s2 = s1.clone_immut(); 
    let t1 = my_spawn(&s1);
    let t2 = my_spawn(&s2); 
    t1.join();
    t2.join();
    drop(s2);
    let mut s3 = s1.back_to_mut();
    s3.push_str("World");
}
\end{lstlisting}
\chapter{考察}
ソースコード\ref{random_example}は、\texttt{Rc}オブジェクトを用いることで以下のソースコード\ref{rc_random}のように表すことができる。
しかし、本研究の新たな参照オブジェクトは、\texttt{Rc}オブジェクトを利用した際には検出することができない、オブジェクトの解放し忘れを実行時に検出することができる。これは、\texttt{Rc}オブジェクトを用いる場合と異なる点であり、新たな参照オブジェクトを利用するメリットであると考えた。
\begin{lstlisting}[language=Rust, caption=新たな参照オブジェクトを用いた並列処理の例, label=rc_random, captionpos=b]
fn remove_string(vec: &mut Vec<Rc<String>>, s: String) {
    vec.retain(|x| **x != s);
}

fn main() {
    let mut vec: Vec<Rc<String>> = Vec::new();
    let h = String::from("Hello");
    let w = String::from("World");
    let mut rng = rand::thread_rng();
    let h_immut = Rc::new(h);
    let w_immut = Rc::new(w);
    for _ in 0..10 {
        if rng.gen() {
            let h_clone = h_immut.clone();
            vec.push(h_clone);
        }
        else {
            let w_clone = w_immut.clone();
            vec.push(w_clone);
        }
    }
    remove_string(&mut vec, String::from("Hello"));
    let mut h_mut = Rc::into_inner(h_immut).unwrap();
    h_mut.push_str("hoge");
    println!("{}", h_mut);
    drop(h_mut);
}
\end{lstlisting}

また、新たな参照オブジェクトがメモリ安全であるかをRustBelt\cite{10.1145/3158154}を用いて証明できるか検討した。
RustBeltを用いると、unsafeな機能を用いた際でも、メモリ安全であるかを証明することができる。\texttt{Rc}オブジェクトは実装にunsafeな機能が用いられているが、RustBeltによってメモリ安全であることが証明されている。本研究の参照オブジェクトは、\texttt{Rc}オブジェクトの利用方法を強制しているオブジェクトであるため、\texttt{Rc}オブジェクトを用いて本研究の参照オブジェクトを実装できれば、メモリ安全であることが証明できると考えた。しかし、unsafeな機能を用いなければ実装することができなかったため、本研究の参照オブジェクトがメモリ安全であるかは、RustBeltを用いて新たに証明する必要があった。

\chapter{関連研究}
本研究で取り入れた、fractional ownership\cite{10.1007/3-540-44898-5_4}は、有理数計画法を用いて静的に検査されている。

また、RustBelt\cite{10.1145/3158154}によりunsafeな機能を用いた際でもメモリ安全であるか証明でき、\texttt{Rc}オブジェクトなどの一部のオブジェクトはメモリ安全であることが証明されている。

また、RustでなくC言語の特定のプログラムでメモリ関連のエラーがないことがfractional ownershipにより検証されている。\cite{10.1007/978-3-642-10672-9_11}また、fractional ownershipとRustの静的なownershipを組み合わせた新たな所有権型が提案されており、提案した型システムにより命令型プログラムが検証されている。\cite{10.1007/978-3-031-50521-8_11}


\chapter{結論と今後の課題}
fractional ownershipの考え方を取り入れ、Rustの静的なownershipによるメモリ管理と、動的な参照カウントの柔軟性を組み合わせた新たな参照オブジェクトを提案した。この参照オブジェクトにより、オブジェクトの解放し忘れを実行時に検出し、メモリリークを防ぐことができる。
また今後の課題として、新たな参照オブジェクトがメモリ安全であることを証明することや、本来のfractional ownershipのように静的な検査にすることがあげられる。

\backmatter% ここから後付
\chapter{謝辞}
本論文の執筆にあたりご指導くださった住井英二郎教授に感謝申し上げます。
ゼミや発表でご指摘くださった松田一考准教授、Oleg Kiselyov助教、
住井・松田研究室の皆様に感謝申し上げます。

% % %% 参考文献: bibtex
% \cite{10.1007/3-540-44898-5_4}
% \cite{10.1145/3158154}
% \cite{10.1007/978-3-642-10672-9_11}
% \cite{10.1007/978-3-031-50521-8_11}
\bibliographystyle{jplain}
\bibliography{refs}

\end{document}
